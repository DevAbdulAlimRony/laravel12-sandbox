## artisan file:
1. Artisan is Laravel’s command-line entry point. We know the request lifecycle of laravel starts from index.php, but for console request it starts from this file.
2. artisan is to Laravel what index.php is to a web request.
3. Browser → public/index.php, Terminal → artisan.
4. when you run php artisan: This artisan file is what actually starts Laravel.
5. Artisan = skilled craftsperson, Artisan CLI = developer’s tool to “craft” the application.
6. It does not have an extension, Because it is meant to be executed as a command, not included as a PHP file. On Unix/Linux systems: Files don’t need extensions.
7. ./artisan or php artisan both work.
8. #!/usr/bin/env php: This is called a shebang. It tells the OS: “Use the PHP interpreter to run this file. So, it can run without extension.
9. define('LARAVEL_START', microtime(true)): Records application start time. Used for performance, debugginh and profiling.
10. require __DIR__.'/vendor/autoload.php': Loads all Composer packages, Enables PSR-4 autoloading, Makes all classes available. Without this → nothing works.
11.  require_once __DIR__.'/bootstrap/app.php': Creates Laravel application instance, Loads config, services, providers, Prepares the framework.
     - __DIR__ is used so PHP can find the file correctly no matter from where the script is executed. the absolute directory path of the current file, at runtime.
     - Exp: /var/www/myapp, so this line require __DIR__.'/vendor/autoload.php' becomes require '/var/www/myapp/vendor/autoload.php'.
12. $app->handleCommand(new ArgvInput): Reads terminal arguments (php artisan migrate), Finds the matching command, Executes it, Returns exit code.
13. exit($status): Returns success/failure code to OS, Used by CI/CD & scripts.
14. All real logic lives in: Illuminate\Console\Command
15. Artisan just starts Laravel, passes control.

## .gitignore: .gitignore tells Git which files and folders should NOT be tracked.
On Linux/Unix, files starting with . are hidden files.
It has no extension because Git recognizes it by name, not type.
Comments start with # and are used for documentation.
It prevents committing secrets, dependencies, logs, and build files.
.gitignore is meant to be a config file, not a normal document.
 Git looks for a file named exactly .gitignore. 
1. You write patterns, one per line.
2. Ignore a file: .env
3. Ignore a folder: /vendor, /public/build
4. Ignore files by extension: *.log
5. Ignore inside folders: storage/*.log
6. Use comments: # This is a comment
7. Force include a file: !.env.example

## .gitattributes:
1. .gitattributes tells Git how files should be treated, not whether they should be tracked.
2. It controls behaviors like line endings, file comparison, exports, and diffs.
3. It ensures files behave consistently across different operating systems (Windows, Linux, macOS).
4. It prevents issues caused by different line endings (CRLF vs LF).
5. It tells Git which files are source code, binary, or generated.
6. It can exclude files from git archive exports (release packages).
7. It helps keep repositories clean and avoids unnecessary merge conflicts.
8. .gitignore decides what files Git should ignore.
   .gitattributes decides how Git should handle files that are tracked.
9. * tells Git to ignore everything inside the folder.
10. !.gitignore tells Git to track the .gitignore file itself.

## .env.example:
1. .env.example provides a template of environment variables required by the application.
2. It helps new developers quickly create their own .env file without exposing secrets.
3. It ensures consistent environment configuration across teams and deployments.

## .editorconfig enforces consistent coding style (indentation, line endings, spacing) across different editors and IDEs for all developers.

## vendor: All installed php packages and libraries.

## node_modules: All Installed npm packages.

## bash.exe.stackdump is a crash dump file created when Git Bash or Bash for Windows crashes.
   - It contains debugging information (stack trace) used to diagnose the crash.
   - It is automatically generated by Cygwin / MSYS2 / Git Bash, not by Laravel or PHP.
   - It is safe to delete and can reappear if the crash happens again.

## public/.htaccess: 
1. .htaccess is an Apache web server configuration file.
2. It controls how requests are handled before Laravel runs.
3. In Laravel, it mainly: edirects all requests to index.php, Enables URL rewriting (/login instead of /index.php/login)
4. It blocks direct access to sensitive files.
5. It ensures Laravel routing works correctly.

## public/robots.txt: 
1. robots.txt tells search engine bots what they are allowed to crawl.
2. User-agent: * means all bots (Google, Bing, etc.).
3. Disallow: / means do not crawl any page on this site.
4. It Prevents search engines from indexing Local development sites, Staging servers, Private/admin apps.
5. Avoids leaking unfinished or internal pages to Google.
6. Protects SEO from indexing wrong environments.
7. For a public production website, change to: User-agent: *, Allow: / or remove the file entirely.
8. Exp: public folders, but seo cant index the admin pannel
   User-agent: *
   Allow: /
   Disallow: /admin
   Disallow: /login
   Disallow: /dashboard
- This setup is ideal for public websites with private admin areas.

## public/hot: 
1. The hot file is created by Vite during development.
2. It tells Laravel: Assets are served from the Vite dev server.
3. Used for: Hot Module Reload (HMR), Instant frontend updates without rebuild.
4. Its created when you run npm run dev.
5. Laravel checks for this file to decide: dev assets OR, production assets.
6. hot file dont or should not exist in production, and should not removed from development.

## public/build: generated when you run npm run build.
- It includes js bundles, css files, manifest.json
- If we remove this from development server, not problem if hot exists.
- Laravel checks: If public/hot exists → use Vite dev server, Else → use public/build.

